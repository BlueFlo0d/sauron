* sauron

  *WARNING* sauron is in its early stages of development. Okay, now I warned
  you.

** what is it?

   *sauron* is an emacs mode for keeping track of /events/ happening in the
   (emacs) world around you. Events are things like 'appointment in 5 minutes',
   'bob pinged you on IRC', 'torrent download is complete' etc. Sauron shows
   those events like a list -- basically like a log. You can 'activate' an event
   by clicking it. 

   When activated, it can execute some arbitrary function -- for example in the
   case of IRC (ERC), it will switch you to the buffer (channel) it originated
   from. It's a bit of a generalization of what /tracking mode/ does in ERC (the
   emacs IRC client), and that is in fact how it started.

   For my work, I need to keep track of a bunch of ERC (IRC) channels and at the
   same time not forget to go to meetings, even when I'm concentrating on
   something else. So, I want something tweakable to provide me with the right
   balance between obnoxiousness and ignorability. Thus, sauron was born.
   
   There's an increasing number of hooks and tunables in sauron, but I strive
   for it to be useful with minimal configuration.

** getting started

   After you've put the various sauron files in a directory, you can enable it
   with something like the following in your =.emacs=:

   ;; set load path, obviously replace "<path-to-sauron-dir>" with the actual path...
   #+being_example
:   (add-to-list 'load-path "<path-to-sauron-dir>")
:   (require 'sauron)
   #end_example
   
   Now, you can start sauron with... =M-x sauron-start=, and stop it with =M-x
   sauron-stop=.

   =sauron-start= will pop-up a new frame (window) which will show events coming
   from any of its sources (i.e.., ERC, org-mode appointments and over
   d-bus). You can 'activate' a source by pressing "Enter" with the cursor on
   the event, which will then take some backend-specific action. 

   For example, for the ERC-backend, it will transfer you to the buffer
   (IRC-channel) where said event happened. 

   You can clear all events with =M-x sauron-clear= (default keybinding: =c=).

   Sauron (by default) loads the =sauron-erc=, =sauron-org= and =sauron-dbus=
   modules; if you don't have ERC, org-mode or d-bus support, these will simply
   be ignored. If so desired, you can customize =sauron-modules=. See below for
   some specifics about the backends.
   

** customization
   
   I've tried hard to come up with reasonable defaults, such that users can get
   started with sauron without reading too much documentation or having to write
   emacs-lisp etc.; still, I've also tried to make sauron very configurable -
   different people have different needs, so it should be possible to coerce the
   software in whatever direction.

   Below are some customization points.

*** priorities -- =sauron-min-priority=

    Each event in sauron has a certain /priority/. Sauron *ignores* all events
    which have a priority that is lower that =sauron-min-priority= (default
    value: 3).

    For example, all message written on IRC (i.e., coming from the ERC-backend)
    which are *not* directed towards you have priority 2 -- you will not see
    them. And that is probably a good idea.

*** watching patterns -- =sauron-watch-patterns=
    
    You can specify a list of patterns (regular expressions) which sauron should
    check. An event matching any of the patterns in the list will have its
    priority raised by 1 point. If that one point raises it to
    `sauron-min-priority' level, it will now show up in the Sauron buffer.

    =sauron-watch-patterns= is useful if you want to check if, for example, your
    name, or your hobby project is mentioned in some IRC channel.

    So, for example, as part of your settings:
    #+begin_example
:;; watch for some animals
:(setq sauron-watch-patterns
:  '("\\bgnu\\b" "yak" "capybara" "wombat"))
    #+end_example

*** watching nicks -- =sauron-watch-nicks=

    You can also specify a list of nicks to watch for; nicks are matched using a
    string-match (not a regular expression). A nick matching any of the nicks in
    the list will have its priority raised by 1 point. If that one point raises
    it to `sauron-min-priority' level, it will now show up in the Sauron buffer.

*** don't get swamped by a certain nick

    Since you may not want to get too many events from one nick -- and, who
    knows, accompanying sound effects, pop-ups and what have you, you can set
    some insensitivity time; events from the same nick during this time will be
    lowered in priority by one point.

    You can set the time period (in seconds) with `sauron-nick-insensitivity',
    which defaults to 60 seconds.

*** blocking events from showing up -- =sauron-event-block-functions=
    
    We can customize things even more precisely using the
    =sauron-event-block-functions= hook function. Any event with a priority >=
    =sauron-min-priority= will be passed to the hook function(s); if any of
    those functions returns non-nil, the event will be blocked. See the emacs
    documentation for a general introduction to hook functions, here's an
    example:
    #+begin_example
    :(add-hook 'sauron-event-block-functions
:  (lambda (origin prio msg &optional props)
:    (or
:      (string-match "foo" msg) ;; ignore events that match 'foo' 
:      ;; other matchers
:     )))
    #+end_example

    Note that the =props= parameter is a backend specific property-list, which
    allows you e.g. (for the ERC-backend) to get the sender of some ERC message,
    and block based on that.

*** doing stuff based on events -- =sauron-event-added-functions=

    After events have been added, another hook is called:
    =sauron-event-added-functions=.  

    This is place to add sound effects, notifications and so on. After all, if
    you get an event for e.g. the org-mode backend that you have a meeting to
    attend in 5 minutes, simply adding a line in the Sauron-buffer may not be
    enough.

    Instead, you can define a hook function for this. To make this easy, a few
    convenience functions are provided:
    - ~sauron-sox~ (play a sound using 'sox')
    - ~sauron-aplay~ (play a sound using 'aplay')
    - ~sauron-gnome-osd~ (show some letters on your screen)
    - ~sauron-zenity~ (pop up a zenity window)
    (see the doc-strings for the functions for the details about their
    parameters).
    
    Now, our hook function could look something like:

    #+begin_example
    :(add-hook 'sauron-event-added-functions
:  (lambda (origin prio msg &optional props)
:    (if (string-match "ping" msg)
:      (sauron-sox "/usr/share/sounds/ping.wav")
:      (sauron-sox "/usr/share/sounds/something-happened.wav"))
:    (when (>= prio 4)
:	(sauron-sox "/common/sounds/uhoh.wav")
:	(sauron-gnome-osd msg 10))))
    #+end_example

** the backend modules

   TODO

*** erc

*** org-mode / appt

*** d-bus

    
** adding new modules
   
   It may be interesting to track other modules as well; this shouldn't be too
   hard. Suppose we have a module 'foo':

   - create "sauron-foo.el", and make sure it's in the load-path
   - sauron-foo should implement at least:
     + ~sauron-foo-start~ to start the module
     + ~sauron-foo-stop~ to stop the module / cleanup etc.
   - add sauron-foo.el with =(provide 'sauron-foo)=
   - now, add ~sauron-foo~ to your ~sauron-modules~

   Now, to actually make your module useful, you'd want to add some event is
   something happens. This is done using =sauron-add-event= (see it's
   documentation).

** sample configuration

   TODO

