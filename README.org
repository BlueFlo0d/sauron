* sauron

  *WARNING/HUOM* sauron is in its early stages of development (basicly, one
   evening of hacking. It's not ready for general consumption.

** but what is it?

  sauron is an emacs mode for keeping track of what goes on in the world
  behind you. Modern desktop environments have all kinds of fancy widgets
  etc. that steal my attention (or sometimes not enough), so I figured it's
  better to have emacs give me buffer which list all the important events.

  What kind of events? Well, sauron started because during my work, I need to
  track a lot of IRC channels. I'm using [[http://www.emacswiki.org/emacs/ERC][ERC]] as my IRC-client, and it's not
  always totally obvious is someone 'pinged' me in some channel. It provides a
  number of hooks, but I wasn't able to make them behave the way I like --
  that is, give me a short description of what's happening, and teleport me to
  the channel in question at the click of a button (later I found, ERC may
  actually have some built-ins capable of that, but alas...)

  So, I started writing Sauron as the Ã¼ber hook function to deal with ERC
  channel, when it occured to me that I could actually do it a bit more
  general -- say, warn me of new e-mails, if a torrent has completed, and so
  on.

  Needless to say (but I do it anyway), there is a fine balance between
  getting the useful messages and /spam/, and that balance differs from person
  to person.
  
** customization
   
   I've tried hard to come up with reasonable defaults, such that users can get
   started with sauron without reading too much documentation or having to write
   emacs-lisp etc.; still, I've also tried to make sauron very configurable -
   different people have different needs, so it should be possible to coerce the
   software in whatever direction.

   Below are some customization points.

*** priorities -- =sauron-min-priority=

    Each event in sauron has a certain /priority/. Sauron *ignores* all events
    which have a priority that is lower that =sauron-min-priority= (default
    value: 3).

    For example, all message written on IRC (i.e., coming from the ERC-backend)
    which are *not* directed towards you have priority 2 -- you will not see
    them. And that is probably a good idea.

*** watching patterns -- =sauron-watch-patterns=
    
    You can specify a list of patterns (regular expressions) which sauron should
    check. An event matching any of the patterns in the list
    =sauron-watch-patterns= of which the priority is currently below
    =sauron-min-priority= (see above), will have its priority raised to
    =sauron-min-priority=. In other words, a message that would otherwise be
    ignored, will now show up in the Sauron buffer.

    =sauron-watch-patterns= is useful if you want to check if, for example, your
    name, or your hobby project is mentioned in some IRC channel.

*** blocking events from showing up -- =sauron-event-block-functions=
    
    We can customize things even more precisely using the
    =sauron-event-block-functions= hook function. Any event with a priority >=
    =sauron-min-priority= will be passed to the hook function(s); if any of
    those functions returns non-nil, the event will be blocked. See the emacs
    documentation for a general introduction to hook functions, here's an
    example:
#+begin_example
(add-hook 'sauron-event-block-functions
  (lambda (origin prio msg &optional props)
    (or
      (string-match "foo" msg) ;; ignore events that match 'foo' 
      ;; other matchers
     )))
#+end_example

    Note that the =props= parameter is a backend specific property-list, which
    allows you e.g. (for the ERC-backend) to get the sender of some ERC message,
    and block based on that.

*** doing stuff based on events -- =sauron-event-added-functions=

    After events have been added, another hook is called:
    =sauron-event-added-functions=.  

    This is place to add sound effects, notifications and so on. After all, if
    you get an event for e.g. the org-mode backend that you have a meeting to
    attend in 5 minutes, simply adding a line in the Sauron-buffer may not be
    enough.

    Instead, you can define a hook function for this. To make this easy, a few
    convenience functions are provided:
    - ~sauron-sox~ (play a sound using 'sox')
    - ~sauron-aplay~ (play a sound using 'aplay')
    - ~sauron-gnome-osd~ (pops up some letters on your screen)
    - ~sauron-zenity~ (pop up a zenity window)
    (see the doc-strings for the functions for the details about their
    parameters).
  
    Now our, function can look something like:

#+begin_example
(add-hook 'sauron-event-added-functions
  (lambda (origin prio msg &optional props)
    (if (string-match "ping" msg)
      (sauron-sox "/common/sounds/ping.wav")
      (sauron-sox "/common/sounds/something-happened.wav"))
    (if (>= prio 4)
      (progn
	(sauron-sox "/common/sounds/uhoh.wav")
	(sauron-gnome-osd (concat event-type "@" origin ": " msg) 10)))))
#+end_example
       
** adding new modules
   
   It may be interesting to track other modules as well; this shouldn't be too
   hard. Suppose we have a module 'foo':

   - create "sauron-foo.el", and make sure it's in the load-path
   - sauron-foo should implement at least:
     + ~sauron-foo-start~ to start the module
     + ~sauron-foo-stop~ to stop the module / cleanup etc.
   - add sauron-foo.el with =(provide 'sauron-foo)=
   - now, add ~sauron-foo~ to your ~sauron-modules~

   Now, to actually make your module useful, you'd want to add some event is
   something happens. This is done using =sauron-add-event= (see it's
   documentation).

    

